ft_memset:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_bzero:      [OK] [OK] [OK] [OK] 
ft_memcpy:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_memccpy:    [MISSING]
ft_memmove:    [OK] [OK] [OK] [OK] [FAILED] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
[fail]: your memmove does not support the overlap (test 1)
Test code:
	char dst1[0xF0];
	char dst2[0xF0];
	char *data = "thiÃŸ ÃŸ\xde\xad\xbe\xeftriÃ±g will be Ã¸vÃ©rlapÃ©d !\r\n";
	int size = 0xF0 - 0xF;

	__builtin___memset_chk (dst1, 'A', sizeof(dst1), __builtin_object_size (dst1, 0));
	__builtin___memset_chk (dst2, 'A', sizeof(dst2), __builtin_object_size (dst2, 0));
	__builtin___memcpy_chk (dst1, data, strlen(data), __builtin_object_size (dst1, 0));
	__builtin___memcpy_chk (dst2, data, strlen(data), __builtin_object_size (dst2, 0));
	__builtin___memmove_chk (dst1 + 3, dst1, size, __builtin_object_size (dst1 + 3, 0));
	ft_memmove(dst2 + 3, dst2, size);
	if (!memcmp(dst1, dst2, size))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     memmove: |thithiÃŸ ÃŸÞ­¾ïtriÃ±g will be Ã¸vÃ©rlapÃ©d !
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA”|
  ft_memmove: |thithiÃŸ ­¾ïtriÃ±g will be Ã¸vÃ©rlapÃ©d !
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAthithiÃŸ ÃŸÞ­¾ïtriÃ±g will be Ã¸vÃ©rlapÃ©d !
AAAAAAAAAAAAAA|

ft_memchr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_memcmp:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strlen:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_isalpha:    [OK] 
ft_isdigit:    [OK] 
ft_isalnum:    [OK] 
ft_isascii:    [OK] 
ft_isprint:    [OK] 
ft_toupper:    [OK] 
ft_tolower:    [OK] 
ft_strchr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strrchr:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strncmp:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strlcpy:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strlcat:    [OK] [OK] [FAILED] [FAILED] [FAILED] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [CRASH] 
[fail]: your strlcat does not work with basic input
Test code:
	char *str = "the cake is a lie !\0I'm hidden lol\r\n";
	char buff1[0xF00] = "there is no stars in the sky";
	char buff2[0xF00] = "there is no stars in the sky";
	size_t max = strlen("the cake is a lie !\0I'm hidden lol\r\n") + strlen("there is no stars in the sky");

	__builtin___strlcat_chk (buff1, str, max, __builtin_object_size (buff1, 2 > 1 ? 1 : 0));
	ft_strlcat(buff2, str, max);
	if (!strcmp(buff1, buff2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strlcat: |there is no stars in the skythe cake is a lie |
  ft_strlcat: |there is no stars in the skyt|

[fail]: your strlcat does not work with over length size
Test code:
	char *str = "the cake is a lie !\0I'm hidden lol\r\n";
	char buff1[0xF00] = "there is no stars in the sky";
	char buff2[0xF00] = "there is no stars in the sky";
	size_t max = 1000;

	__builtin___strlcat_chk (buff1, str, max, __builtin_object_size (buff1, 2 > 1 ? 1 : 0));
	ft_strlcat(buff2, str, max);
	if (!strcmp(buff1, buff2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strlcat: |there is no stars in the skythe cake is a lie !|
  ft_strlcat: |there is no stars in the skyt|

[fail]: your strlcat does not work with a size of 0
Test code:
	char *str = "the cake is a lie !\0I'm hidden lol\r\n";
	char buff1[0xF00] = "there is no stars in the sky";
	char buff2[0xF00] = "there is no stars in the sky";
	size_t max = 0;

	__builtin___strlcat_chk (buff1, str, max, __builtin_object_size (buff1, 2 > 1 ? 1 : 0));
	ft_strlcat(buff2, str, max);
	if (!strcmp(buff1, buff2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strlcat: |there is no stars in the sky|
  ft_strlcat: |there is no stars in the sk|

[crash]: your strlcat crush when null parameter is sent with a size of 0
Test code:
	char b[0xF] = "nyan !";

	ft_strlcat(((void *)0), b, 0);
	exit(TEST_SUCCESS);


ft_strnstr:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_atoi:       [OK] [OK] [OK] [OK] [OK] [OK] [FAILED] [OK] [OK] [OK] [OK] [OK] [KO] [KO] [OK] [OK] [OK] [NO CRASH] 
[fail]: your atoi is not working with non space invisible char
Test code:
	char *n = "\e06050";
	int i1 = atoi(n);
	int i2 = ft_atoi(n);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
        atoi: |0|
     ft_atoi: |6050|

[KO]: your atoi does not work with over long max value
Test code:
	char n[40] = "99999999999999999999999999";
	int i1 = atoi(n);
	int i2 = ft_atoi(n);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
        atoi: |-1|
     ft_atoi: |-469762049|

[KO]: your atoi does not work with over long min value
Test code:
	char n[40] = "-99999999999999999999999999";
	int i1 = atoi(n);
	int i2 = ft_atoi(n);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
        atoi: |0|
     ft_atoi: |469762049|

[no crash]: your atoi does not work with the plus sign and spaces
Test code:
	ft_atoi(((void *)0));


ft_calloc:     [OK] [CRASH] [FAILED] [FAILED] [OK] 
[crash]: you didn't protect your malloc return
Test code:
	char *ptr;

	ptr = ft_calloc(4, 20);
	if (!ptr)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


[fail]: your calloc don't work with empty string
Test code:
	int size = 8539;

	void * d1 = ft_calloc(size, sizeof(int));
	void * d2 = calloc(size, sizeof(int));
	if (memcmp(d1, d2, size * sizeof(int)))
		exit(TEST_FAILED);
	free(d1);
	free(d2);
	exit(TEST_SUCCESS);

Diffs:


[fail]: your calloc don't work with 0 size
Test code:
	void *str = ft_calloc(0, 0);

	if (str == ((void *)0))
		exit(TEST_FAILED);
	free(str);
	exit(TEST_SUCCESS);

Diffs:


ft_strdup:     [CRASH] [OK] [OK] [OK] [OK] [OK] [OK] 
[crash]: you didn't protect your malloc return
Test code:
	char *ptr;

	ptr = ft_strdup("lol");
	if (!ptr)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


ft_substr:     [OK] [OK] [OK] [OK] [OK] [CRASH] [OK] [OK] {not protected}[OK] 
[crash]: you did not protect your malloc
Test code:
	char *s = "malloc protection !";

	char *ret = ft_substr(s, 0, 5);
	if (ret == ((void *)0))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);
	(void)s;
	(void)ft_substr;


ft_strjoin:    [OK] [OK] [OK] [CRASH] [OK] {not protected}
[crash]: you did not protect your malloc return
Test code:
	char *s1 = "where is my ";
	char *s2 = "malloc ???";

	char *res = ft_strjoin(s2, s1);
	if (res == ((void *)0))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


ft_strtrim:    [FAILED] [FAILED] [FAILED] [OK] [OK] [KO] [FAILED] [CRASH] [FAILED] {protected}
[fail]: your strtrim does not work with basic input
Test code:
	char *s1 = "   \t  \n\n \t\t  \n\n\nHello \t  Please\n Trim me !\n   \n \n \t\t\n  ";
	char *s2 = "Hello \t  Please\n Trim me !";
	char *ret = ft_strtrim(s1, " \n\t");

	if (!strcmp(ret, s2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strtrim: |Hello 	  Please
 Trim me !|
  ft_strtrim: |Hello 	  Please
 T|

[fail]: your strtrim does not work with basic input
Test code:
	char *s1 = "   \t  \n\n \t\t  \n\n\nHello \t  Please\n Trim me !";
	char *s2 = "Hello \t  Please\n Trim me !";
	char *ret = ft_strtrim(s1, " \n\t");

	if (!strcmp(ret, s2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strtrim: |Hello 	  Please
 Trim me !|
  ft_strtrim: |Hello 	  Please
 T|

[fail]: your strtrim does not work with basic input
Test code:
	char *s1 = "Hello \t  Please\n Trim me !";
	char *s2 = "Hello \t  Please\n Trim me !";
	char *ret = ft_strtrim(s1, " \n\t");

	if (!strcmp(ret, s2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strtrim: |Hello 	  Please
 Trim me !|
  ft_strtrim: |Hello 	  Please
 T|

[KO]: your strtrim did not allocate the good size so the \0 test may be false
Test code:
	char *s1 = "\t   \n\n\n  \n\n\t    Hello \t  Please\n Trim me !\t\t\t\n  \t\t\t\t  ";
	char *s2 = "Hello \t  Please\n Trim me !";
	int r_size = strlen(s2);
	int size;

	ft_strtrim(s1, " \n\t");
	size = get_last_malloc_size();
	if (size == r_size + 1)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
     strtrim: |27|
  ft_strtrim: |19|

[fail]: your strtrim does not allocate memory
Test code:
	char *s1 = "   \t  \n\n \t\t  \n\n\nHello \t  Please\n Trim me !\n   \n \n \t\t\n  ";
	char *s2 = "Hello \t  Please\n Trim me !";
	char *ret = ft_strtrim(s1, " \n\t");

	if (!strcmp(ret, s2))
	{
		free(ret);
		exit(TEST_SUCCESS);
	}
	free(ret);
	exit(TEST_FAILED);

Diffs:
     strtrim: |Hello 	  Please
 Trim me !|
  ft_strtrim: |Hello 	  Please
 T|

[crash]: you dont protect your malloc return
Test code:
	char *s1 = "   \t  \n\n \t\t  \n\n\nHello \t  Please\n Trim me !\n   \n \n \t\t\n  ";

	char *ret = ft_strtrim(s1, " \n\t");
	if (ret == ((void *)0))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


[fail]: your strtrim does not set \0 to the end of the string
Test code:
	char *s1 = "   \t  \n\n \t\t  \n\n\nHello \t  Please\n Trim me !\n   \n \n \t\t\n  ";
	char *s2 = "Hello \t  Please\n Trim me !";

	char *ret = ft_strtrim(s1, " \n\t");
	if (!strcmp(s2, ret))
	{
		free(ret);
		exit(TEST_SUCCESS);
	}
	free(ret);
	exit(TEST_FAILED);

Diffs:
     strtrim: |Hello 	  Please
 Trim me !|
  ft_strtrim: |Hello 	  Please
 T|

ft_split:      [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [CRASH] [OK] {not protected}
[crash]: you did not protect your split
Test code:
	char *s = "      split       this for   me  !       ";

	char **result = ft_split(s, ' ');
	if (!result)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


ft_itoa:       [FAILED] [OK] [OK] [OK] [FAILED] [CRASH] [KO] [KO] [OK] 
[fail]: your itoa does not work with basic input
Test code:
	char *i1 = ft_itoa(-623);
	char *i2 = ft_itoa(156);
	char *i3 = ft_itoa(-0);

	if (strcmp(i1, "-623"))
	{
		exit(TEST_FAILED);
	}
	if (strcmp(i2, "156"))
	{
		exit(TEST_FAILED);
	}
	if (strcmp("0", i3))
	{
		exit(TEST_FAILED);
	}
	exit(TEST_SUCCESS);

Diffs:
        itoa: |-623|
     ft_itoa: |-Ÿ|

[fail]: your itoa don't set \0 at the end of the string
Test code:

	char *i1 = ft_itoa(-1234);
	if (strcmp(i1, "-1234"))
	{
		exit(TEST_FAILED);
	}
	exit(TEST_SUCCESS);

Diffs:
        itoa: |-1234|
     ft_itoa: |-|

[crash]: you did not protect your malloc
Test code:

	char *i1 = ft_itoa(-1234);
	if (!i1)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


[KO]: your itoa does not allocate the good size so the \0 test may be false
Test code:
	int size;

	ft_itoa(-5859);
	size = get_last_malloc_size();
	if (size == 6)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
        itoa: |6|
     ft_itoa: |3|

[KO]: your itoa does not allocate the good size so the \0 test may be false
Test code:
	int size;

	ft_itoa(0);
	size = get_last_malloc_size();
	if (size == 2)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
        itoa: |2|
     ft_itoa: |3|

ft_strmapi:    [OK] [OK] [OK] [OK] [CRASH] {protected}
[crash]: you did not protect your malloc return
Test code:
	char *b = "override this !";

	char *newstr = ft_strmapi(b, f_strmapi);
	if (newstr == ((void *)0))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


ft_putchar_fd: [OK] [OK] 
ft_putstr_fd:  [OK] [OK] {not protected}
ft_putendl_fd: [OK] [OK] {not protected}
ft_putnbr_fd:  [OK] [OK] [OK] [FAILED] [OK] 
[fail]: your putnbr_fd does not work with random numbers
Test code:
	int nbr;
	char buff[0xF0];

	srand(clock());
	nbr = rand();
	fd_to_buffer(2);
	ft_putnbr_fd(nbr, 2);
	write(2, "", 1);
	get_fd_buffer(2, buff, 0xF0);
	int nb = atoi(buff);
	if (nbr != nb)
	{
		exit(TEST_FAILED);
	}
	;
	srand(clock());
	nbr = rand();
	fd_to_buffer(2);
	ft_putnbr_fd(nbr, 2);
	write(2, "", 1);
	get_fd_buffer(2, buff, 0xF0);
	if (nbr != atoi(buff))
	{
		exit(TEST_FAILED);
	}
	;
	srand(clock());
	nbr = rand();
	fd_to_buffer(2);
	ft_putnbr_fd(nbr, 2);
	write(2, "", 1);
	get_fd_buffer(2, buff, 0xF0);
	if (nbr != atoi(buff))
	{
		exit(TEST_FAILED);
	}
	;
	srand(clock());
	nbr = rand();
	fd_to_buffer(2);
	ft_putnbr_fd(nbr, 2);
	write(2, "", 1);
	get_fd_buffer(2, buff, 0xF0);
	if (nbr != atoi(buff))
	{
		exit(TEST_FAILED);
	}
	;
	exit(TEST_SUCCESS);

Diffs:
   putnbr_fd: |5462275|
ft_putnbr_fd: |54622753|

ft_lstnew:     [MISSING]
ft_lstadd_front: [MISSING]
ft_lstsize:    [MISSING]
ft_lstlast:    [MISSING]
ft_lstadd_back:[MISSING]
ft_lstdelone:  [MISSING]
ft_lstclear:   [MISSING]
ft_lstiter:    [MISSING]
ft_lstmap:     [MISSING]
ft_striteri:   [OK] [OK] {protected}
